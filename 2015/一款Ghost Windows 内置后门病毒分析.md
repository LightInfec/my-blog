##  病毒程序概述



  此次分析的病毒程序是从ghost 版的Windows 中分离出的后门程序,恶意代码采用常规方式加密核心代码防止杀毒软件查杀,当恶意软件启动后,会把自身复制到system32 文件夹下并且改名为svchsot.exe 和svchost.exe 相互混淆,恶意代码自启动方式有两种:注册表启动项和计划任务服务自启动,恶意代码初期感染系统完成之后会从远程站点下载其他的恶意软件进一步感染主机,最后和远程主机建立稳定的后门连接,达到收集被感染的主机信息和监控键盘输入.
 

##  脱壳过程

 

  木马作者采用常规的方法把代码加密保存在.data 段,加密完成后跳到堆去执行代码



![图片](pic_temp7\psb1.png)

 

  入口处的代码里面用了很多nop 和Sleep() 掺杂在一起做代码混淆

 

![img](pic_temp7\psb2.png)

 

  往下跟踪到0x401DF8 处,外壳程序开始对内部的下载者病毒代码进行解密

 

解密前:



![img](pic_temp7\psb3.png)

 

解密后:

 

![img](pic_temp7\psb4.png)

 

  现在把0x404040 处的代码dump 出来,完整的病毒代码就可以开始分析了,接下来分析下载者恶意代码如何使IDA 加载代码失败

 

![img](pic_temp7\psb5.png)

 

  正常情况下,IDA 是可以把文件里面绝大部分的数据都可以正确分析出来的,但是现在在数据分布中可以看到IDA 却只分析其中的一小部分,于是把代码窗口往上面拖动,发现每个区段中都存在一些有问题的数据块

 

![img](pic_temp7\psb6.png)

 

  这显然和真实的情况大有不同,接下来需要到PE 文件中的区段去寻找答案

 

![img](pic_temp7\psb7.png)

 

 .nsp1 区段中指定的数据大小几乎占用了整个文件,所以在这个位置无论怎么修改都是没有办法让IDA 正确反汇编代码的,我的思路是,继续往下跟踪,直到进入恶意代码的入口处再到内存中把整个数据Dump 出来

 

![img](pic_temp7\psb8.png)

 

![img](pic_temp7\psb9.png)

 

![img](pic_temp7\psb10.png)

 

![img](pic_temp7\psb11.png)

 

  往下跟踪到0x401EDC ,0x4E1B1E ,0x401B61 处,发现程序需要从加密的恶意代码中导出Me 函数的地址,最后在0x401E5D 中跳到恶意代码的执行处.然后Dump 出恶意代码的主体部分.

 

把从堆里面Dump 出来的程序拿过来分析导入表,发现导入表中很多关于API 的详细信息(比如:调用模块名和导入的API 名)被修改,和原来直接在代码区段中dump出的导入表相差甚远,于是需要通过手动修复导入表的方式使得IDA 可以正确地反汇编恶意程序



![img](pic_temp7\psb12.png)



![img](pic_temp7\psb13.png)

 

由于导入表和导出表数据在内存中已经被打乱,所以只能通过OD 手工给IDA 上的API 填写名称(尝试过使用复制导入表的方式但是不成功)



![img](pic_temp7\psb14.png)

 

  现在再来看看区段块,还是和原来的dump 出的一样



![img](pic_temp7\psb15.png)

 

  所以我们再次尝试修改区段的大小和偏移位置让IDA 可以正确反汇编恶意代码

 

![img](pic_temp7\psb16.png)

 

  把修改好的Dump 拖放到IDA 中,可以正确解析数据



![img](pic_temp7\psb17.png)

 

##  启动过程

 

  鉴于这只是一部分的恶意代码,其他的代码还在网络端,由于服务器早已经被关闭,没有办法进一步得知该病毒程序的后续攻击步骤以及传染方式,所以下面将会在现有的代码中挑选出有价值的代码分析

 

![img](pic_temp7\psb18.png)

 

  恶意软件中使用到的API Hai 函数从原来的外壳代码中导入,Hai 函数的作用是获取一些关于本地和病毒的信息(见wsprintfA 的注释)

 

![img](pic_temp7\psb19.png)

 

  恶意代码会检查本地运行的杀毒软件,如果存在金山杀毒软件则直接关闭,如果存在瑞星杀毒软件则伪装成为瑞星杀毒软件的升级程序并且下载其他的恶意程序

 

![img](pic_temp7\psb20.png)

 

  接下来外壳程序本身移动到system32 下,并且取一个比较有意思的名字—svchsot.exe 来和svchost.exe 混淆,然后通过CreateFile打开自身文件死锁使得其它进程无法访问该文件,从而使得删除病毒代码失败,最后通过检测当前是否为虚拟机状态,如果不是在虚拟机中运行那么就开始从远程站点下载恶意程序,URL 列表如下:

 

<http://4.94.140.167:2011/1.exe>

<http://www.af0575.com:2011/1.exe>

<http://www.fz0575.com:2011/1.exe>

<http://www.wk1888.com:2011/1.exe>

 

 

  关于这个恶意代码样本所感染的范围:



![img](pic_temp7\psb21.png)

 

 

##  详细行为分析

 

1. 恶意代码检测虚拟机方式 



![img](pic_temp7\psb22.png)

 

  恶意代码采用常规的CPU 输出端口的方式读取当前主机环境是否为VMWare 系列虚拟机环境(0x100024F8 读取端口返回的信息,0x100024F9 判断信息是否为VMWare 环境返回的特征码)

 

2.病毒隐藏和自启动方式

 

![img](pic_temp7\psb23.png)
 

  恶意代码把自身复制到C:\WINDOWS\system32\svchsot.exe,然后锁住文件防止被杀毒软件删除,如果该文件已经存在system32目录下,那么恶意代码将会在注册表的启动项中设置它为开机自动启动,做好上面的准备以后在system32 目录下再创建JH.BAT 批处理文件,该文件作用为启用本地的计划任务服务,然后设置每天的整点运行已经转移的恶意代码,最后执行改文件并且通知仿冒的瑞星升级程序退出更新.

 

3. 键盘监听



  在恶意代码的数据部分捕获到键盘键值,于是可以推测恶意代码存在监听本地键盘输入的可能



![img](pic_temp7\psb24.png)



![img](pic_temp7\psb25.png)

 

  由X-refs 返回到被调用的地方可知,恶意软件监听键盘的原理是通过注入新线程到系统桌面线程,从而监听到所有由系统返回到前台的按键信息

 

![图片](pic_temp7\psb26.png)

 

4. 后门分析

 

![img](pic_temp7\psb27.png)

 

  恶意代码为了要获取更大的执行代码的权限,把程序提升到调试程序的权限



![img](pic_temp7\psb28.png)

 

  本地信息获取,当然这只是其中的一部分,恶意代码还会获取本地系统信息,磁盘信息还有网络信息,由于代码实在太多于是只截出其中一个.

 

![img](pic_temp7\psb29.png)

 

  后门程序是一个反向的Shell ,在成功建立连接之后,客户端向服务器发送登陆指令(0x05,0x02,0x00,0x02) 和控制指令(0x05,0x01,0x00,0x01,转换成数字的IP 地址,指定端口)

​                               

![img](pic_temp7\psb30.png)



  后门线程一直等待接收指令,最后会递交到一个类的函数里面去执行处理业务,由于服务器早已经被恶意代码的作者关闭,无法调试到此(其实还是),于是接下来也只能放弃后续的挖掘
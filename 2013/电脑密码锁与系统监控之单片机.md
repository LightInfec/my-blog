由于最近比较闲,所以没有什么事情好做,于是想起了去年台风的一晚上和博记约定要搞个输入密码才可以启动电脑的硬件,不过后来因许多原因而不了了之,今忆起往事,所以才把它做好,到时候回去和同学们在大排档里吹水也有东西来吹.鉴于这个系统的代码量较大,在此只给出代码的下载地址和片上系统(RIOS )的系统架构图,如果你还有什么好的想法的话可以在此基础上加已改进.现在,监控系统不单止是可以支持输入密码启动电脑,还支持接收上位机(RTU )的监控系统性能的数据,当然,也可以在线修改RIOS 启动密码..


![img](pic_temp8\psb1.jpg)



![图片](pic_temp8\psb2.jpg)




在系统的底部,有六个驱动程序用来控制外围硬件(之前导师问为什么要把它称作驱动而不是实现某些硬件功能的构造函数,在我看来,驱动就是软件和硬件交流的桥梁[虽然驱动是用软件写的],它还提供一系列应用编程接口给上层应用程序或者内核来调用.在这里也一样,每个.C 文件只做属于它应该做的事,并且向上提供编程接口来控制主控芯片的外围硬件,于是习惯性地把它们称之为驱动),内核模块monitor_system_trance_data [这个驱动是用于和RTU 进行信息交互的,关于数据交互的详细的数据包结构和标志在monitor_system_code_trance.h 里面保存着]是基于驱动device_52_trance 拓展的;模块monitor_system_code_password [用于在EEPROM 内读/写密码]是基于驱动device_eeprom 拓展的.最后,monitor_system_chip 把所有接口都汇总起来,构建RIOS 的核心代码,为什么不把它称作内核呢?觉得吧,它只不过是把这么多接口都使用一遍的代码文件,归根到底都还只是"使用别人的东西","只不过是这些代码的用户罢了".



最后还要提及的就是RIOS 使用到的引脚定义:



```c
    //  P0 给keyboard 进行数据接收用
    //  lcd_1602 控制引脚 
    sbit lcdrs=P1^0;
    sbit lcdrw=P1^1;
    sbit lcden=P1^2;
    //  P2 是lcd_1602 用来进行数据传输的
    //  芯片端串行数据传输引脚
    sbit data_in=P3^0;
    sbit data_out=P3^1;
    //  AT24C02 EEPROM IIC 总线传输引脚
    sbit scl=P3^6;
    sbit sda=P3^7;
    //  启动PC 端电源引脚(注意,它的原理是通过控制继电器引发主板PWR 端连)
    sbit io_switch_elect =P3^5;
    //  PC 端运行电压检测引脚
    sbit io_interrupt_0=P3^2;
```



Link : https://github.com/lcatro/monitor_system